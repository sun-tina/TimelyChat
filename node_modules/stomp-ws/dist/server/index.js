'use strict';

var WebSocket = require('ws');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var WebSocket__default = /*#__PURE__*/_interopDefaultLegacy(WebSocket);

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

class MalformedFrameError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, MalformedFrameError.prototype);
  }

}
const textDecoder = new TextDecoder();
const textEncoder = new TextEncoder();

function escape(str) {
  return str.replace(/\\/g, "\\\\").replace(/\r/g, "\\r").replace(/\n/g, "\\n").replace(/:/g, "\\c");
}

function unescape(str) {
  return str.replace(/\\\\/g, "\\").replace(/\\r/g, "\r").replace(/\\n/g, "\n").replace(/\\c/g, ":");
}

function encode(frame) {
  const {
    command,
    headers,
    body
  } = frame;
  let str = command + "\n";

  if (headers) {
    for (const key in headers) {
      if (Object.prototype.hasOwnProperty.call(headers, key)) {
        str += escape(key) + ":" + escape(headers[key]) + "\n";
      }
    }
  }

  if (body) {
    const length = body.length;
    const s = textEncoder.encode(str + "content-length:" + length + "\n\n");
    const combined = new Uint8Array(s.length + length + 1);
    combined.set(s);
    combined.set(body, s.length);
    combined[s.length + length] = 0;
    return combined;
  } else {
    return textEncoder.encode(str + "\n\0");
  }
}
function decode(bytes) {
  const buffer = typeof bytes === "string" ? textEncoder.encode(bytes) : new Uint8Array(bytes);

  if (buffer[buffer.length - 1] !== 0) {
    throw new MalformedFrameError("Frame is not terminated with a NULL character.");
  }

  let cursor = 0;

  function getLine() {
    let index = cursor;

    while (index < buffer.length && buffer[index] !== 10) {
      index += 1;
    }

    if (index >= buffer.length) {
      return textDecoder.decode(buffer.slice(cursor));
    }

    const line = textDecoder.decode(buffer.slice(cursor, index));
    cursor = index + 1;
    return line;
  }

  const command = getLine();
  let headerLine = getLine();
  const msg = {
    command
  };

  while (headerLine) {
    const parts = headerLine.split(":");

    if (parts.length !== 2) {
      throw new MalformedFrameError("Contain an invalid header.");
    }

    const key = unescape(parts[0]);

    if (!msg.headers) {
      msg.headers = {};
    }

    if (!msg.headers[key]) {
      const value = unescape(parts[1]);
      msg.headers[key] = value;
    }

    headerLine = getLine();
  }

  const body = buffer.slice(cursor, -1);

  if (body.length) {
    msg.body = body;
  }

  return msg;
}

function verifyHeader(frame, required, optional) {
  const h = { ...frame.headers
  };

  for (const key of required) {
    if (h[key] !== undefined) {
      delete h[key];
    } else {
      throw new MalformedFrameError("Did not contain " + key + " header.");
    }
  }

  if (optional === true) {
    return;
  } else if (optional) {
    for (const key of optional) {
      if (h[key] !== undefined) {
        delete h[key];
      }
    }
  }

  const extra = Object.keys(h);

  if (extra.length > 0) {
    throw new MalformedFrameError("Contain extra header: " + extra.join(", ") + ".");
  }
}

function noBody(frame) {
  if (frame.body) {
    throw new MalformedFrameError("Contain body in " + frame.command + ".");
  }
}

function verifyClient(frame) {
  const {
    command
  } = frame;

  if (command === "CONNECT") {
    noBody(frame);
    verifyHeader(frame, ["accept-version", "host"], ["login", "passcode", "heart-beat"]);
    const heartBeat = frame.headers && frame.headers["heart-beat"];

    if (heartBeat && !/^\d+,\d+$/.test(heartBeat)) {
      throw new MalformedFrameError("Malformed heart-beat option.");
    }
  } else if (command === "SEND") {
    verifyHeader(frame, ["destination"], true);
  } else if (command === "SUBSCRIBE") {
    var _frame$headers;

    noBody(frame);
    verifyHeader(frame, ["destination", "id"], ["ack", "receipt"]);

    if ((_frame$headers = frame.headers) !== null && _frame$headers !== void 0 && _frame$headers.ack && !["auto", "client", "client-individual"].includes(frame.headers.ack)) {
      throw new MalformedFrameError("Contain unknown ack option: " + frame.headers.ack + ".");
    }
  } else if (command === "UNSUBSCRIBE") {
    noBody(frame);
    verifyHeader(frame, ["id"], ["receipt"]);
  } else if (command === "ACK" || command === "NACK") {
    noBody(frame);
    verifyHeader(frame, ["id"], ["transaction", "receipt"]);
  } else if (command === "BEGIN" || command === "COMMIT" || command === "ABORT") {
    noBody(frame);
    verifyHeader(frame, ["transaction"], ["receipt"]);
  } else if (command === "DISCONNECT") {
    noBody(frame);
    verifyHeader(frame, [], ["receipt"]);
  } else {
    return false;
  }

  return true;
}

function toClientFrame(data) {
  if (data.length > 1) {
    const decoded = decode(data);

    if (!verifyClient(decoded)) {
      throw new MalformedFrameError("Unknown command: " + decoded.command);
    }

    return decoded;
  } else if (data[0] !== "\n" && data[0] !== 10) {
    throw new Error("Unknown message: " + data);
  }

  return null;
}

class Server {
  constructor(options) {
    _defineProperty(this, "options", void 0);

    _defineProperty(this, "wss", void 0);

    _defineProperty(this, "_sockets", {});

    _defineProperty(this, "_listeners", []);

    _defineProperty(this, "_sessionListeners", {});

    this.options = options;
  }

  send(session, frame) {
    const socket = this._getSocket(session);

    if (!socket) {
      return;
    }

    socket.send(encode(frame));
  }

  async listen(arg0, arg1) {
    return new Promise((resolve, reject) => {
      if (typeof arg0 === "string") {
        if (this._sessionListeners[arg0]) {
          this._sessionListeners[arg0].push([arg1, resolve, reject]);
        } else {
          this._sessionListeners[arg0] = [[arg1, resolve, reject]];
        }
      } else {
        this._listeners.push([arg0, resolve, reject]);
      }
    });
  }

  close(session) {
    const socket = this._getSocket(session);

    if (!socket) {
      return;
    }

    socket.close();
  }

  _getSocket(session) {
    return this._sockets[session];
  }

  heartBeat(ws, heartBeat, status) {
    const parts = heartBeat.split(",");
    const cx = parseInt(parts[0], 10);
    const cy = parseInt(parts[1], 10);
    const sx = this.options.serverHeartBeat || 0;
    const sy = this.options.clientHeartBeat || 0;
    const clientHeartBeat = cx && sy ? Math.max(cx, sy) : 0;
    const serverHeartBeat = sx && cy ? Math.max(sx, cy) : 0;

    if (serverHeartBeat) {
      const interval = setInterval(() => {
        if (Date.now() - status.lastSend > serverHeartBeat / 2) {
          ws.send("\n");
        }
      }, serverHeartBeat / 2);
      const origSend = ws.send;

      ws.send = (...args) => {
        status.lastSend = Date.now();
        origSend.apply(ws, args);
      };

      ws.addEventListener("close", () => {
        clearInterval(interval);
      });
    }

    if (clientHeartBeat) {
      const interval = setInterval(() => {
        if (Date.now() - status.lastRecv > clientHeartBeat * 1.5) {
          ws.close();
        }
      }, clientHeartBeat);
      ws.addEventListener("message", () => {
        status.lastRecv = Date.now();
      });
      ws.addEventListener("close", () => {
        clearInterval(interval);
      });
    }
  }

  start() {
    const wss = new WebSocket__default['default'].Server({
      server: this.options.server,
      path: this.options.path
    });
    wss.on("connection", ws => {
      const status = {
        lastSend: 0,
        lastRecv: 0
      };
      const terminate = setTimeout(() => {
        ws.close();
      }, this.options.clientHeartBeat || 5000);

      const onmessage = data => {
        try {
          const frame = toClientFrame(data);

          if (!frame) {
            throw new Error("Unexpected heart beat before CONNECT.");
          }

          if (frame.command !== "CONNECT") {
            throw new Error("Unexpected frame " + frame.command + " before CONNECT.");
          }

          clearTimeout(terminate);
          ws.off("message", onmessage);
          Promise.resolve(this.options.getSession(frame)).then(session => {
            this._sockets[session] = ws;
            const sx = this.options.serverHeartBeat || 0;
            const sy = this.options.clientHeartBeat || 0;
            status.lastRecv = Date.now();
            status.lastSend = Date.now();
            ws.send(encode({
              command: "CONNECTED",
              headers: {
                version: "1.2",
                session: session,
                "heart-beat": `${sx},${sy}`
              }
            }));
            this.heartBeat(ws, frame.headers["heart-beat"] || "0,0", status);

            const onmessage = data => {
              try {
                const frame = toClientFrame(data);

                if (!frame) {
                  return;
                }

                function listen(list) {
                  if (!frame) {
                    return;
                  }

                  for (const obj of list) {
                    const [fn, resolve, reject] = obj;

                    const off = () => {
                      const index = list.indexOf(obj);

                      if (index !== -1) {
                        list.splice(index, 1);
                      }
                    };

                    Promise.resolve(fn(frame, session)).then(processed => {
                      if (processed) {
                        resolve(frame);
                        off();
                      }
                    }).catch(err => {
                      reject(err);
                      off();
                    });
                  }
                }

                listen(this._listeners);
                const listeners = this._sessionListeners[session];

                if (listeners) {
                  listen(listeners);
                }
              } catch (err) {
                ws.send(encode({
                  command: "ERROR",
                  headers: {
                    message: err.message
                  }
                }));
                ws.close();
              }
            };

            ws.on("message", onmessage);
            ws.on("close", () => {
              this.options.onClose(session);

              if (this._sessionListeners[session]) {
                for (const obj of this._sessionListeners[session]) {
                  obj[2](new Error("Socket closed"));
                }
              }

              delete this._sessionListeners[session];
              delete this._sockets[session];
              clearTimeout(terminate);
            });
          }).catch(err => {
            ws.send(encode({
              command: "ERROR",
              headers: {
                message: err.message
              }
            }));
            ws.close();
          });
        } catch (err) {
          ws.send(encode({
            command: "ERROR",
            headers: {
              message: err.message
            }
          }));
          ws.close();
        }
      };

      ws.on("message", onmessage);
    });
    this.wss = wss;
  }

  stop() {
    if (this.wss) {
      this.wss.close();
    }
  }

}

module.exports = Server;
//# sourceMappingURL=index.js.map
