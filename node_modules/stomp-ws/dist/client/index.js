'use strict';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

class MalformedFrameError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, MalformedFrameError.prototype);
  }

}
const textDecoder = new TextDecoder();
const textEncoder = new TextEncoder();

function escape(str) {
  return str.replace(/\\/g, "\\\\").replace(/\r/g, "\\r").replace(/\n/g, "\\n").replace(/:/g, "\\c");
}

function unescape(str) {
  return str.replace(/\\\\/g, "\\").replace(/\\r/g, "\r").replace(/\\n/g, "\n").replace(/\\c/g, ":");
}

function encode(frame) {
  const {
    command,
    headers,
    body
  } = frame;
  let str = command + "\n";

  if (headers) {
    for (const key in headers) {
      if (Object.prototype.hasOwnProperty.call(headers, key)) {
        str += escape(key) + ":" + escape(headers[key]) + "\n";
      }
    }
  }

  if (body) {
    const length = body.length;
    const s = textEncoder.encode(str + "content-length:" + length + "\n\n");
    const combined = new Uint8Array(s.length + length + 1);
    combined.set(s);
    combined.set(body, s.length);
    combined[s.length + length] = 0;
    return combined;
  } else {
    return textEncoder.encode(str + "\n\0");
  }
}
function decode(bytes) {
  const buffer = typeof bytes === "string" ? textEncoder.encode(bytes) : new Uint8Array(bytes);

  if (buffer[buffer.length - 1] !== 0) {
    throw new MalformedFrameError("Frame is not terminated with a NULL character.");
  }

  let cursor = 0;

  function getLine() {
    let index = cursor;

    while (index < buffer.length && buffer[index] !== 10) {
      index += 1;
    }

    if (index >= buffer.length) {
      return textDecoder.decode(buffer.slice(cursor));
    }

    const line = textDecoder.decode(buffer.slice(cursor, index));
    cursor = index + 1;
    return line;
  }

  const command = getLine();
  let headerLine = getLine();
  const msg = {
    command
  };

  while (headerLine) {
    const parts = headerLine.split(":");

    if (parts.length !== 2) {
      throw new MalformedFrameError("Contain an invalid header.");
    }

    const key = unescape(parts[0]);

    if (!msg.headers) {
      msg.headers = {};
    }

    if (!msg.headers[key]) {
      const value = unescape(parts[1]);
      msg.headers[key] = value;
    }

    headerLine = getLine();
  }

  const body = buffer.slice(cursor, -1);

  if (body.length) {
    msg.body = body;
  }

  return msg;
}

function verifyHeader(frame, required, optional) {
  const h = { ...frame.headers
  };

  for (const key of required) {
    if (h[key] !== undefined) {
      delete h[key];
    } else {
      throw new MalformedFrameError("Did not contain " + key + " header.");
    }
  }

  if (optional === true) {
    return;
  } else if (optional) {
    for (const key of optional) {
      if (h[key] !== undefined) {
        delete h[key];
      }
    }
  }

  const extra = Object.keys(h);

  if (extra.length > 0) {
    throw new MalformedFrameError("Contain extra header: " + extra.join(", ") + ".");
  }
}

function noBody(frame) {
  if (frame.body) {
    throw new MalformedFrameError("Contain body in " + frame.command + ".");
  }
}
function verifyServer(frame) {
  const {
    command
  } = frame;

  if (command === "CONNECTED") {
    noBody(frame);
    verifyHeader(frame, ["version"], ["session", "server", "heart-beat"]);
    const heartBeat = frame.headers && frame.headers["heart-beat"];

    if (heartBeat && !/^\d+,\d+$/.test(heartBeat)) {
      throw new MalformedFrameError("Malformed heart-beat option.");
    }
  } else if (command === "MESSAGE") {
    verifyHeader(frame, ["destination"], true);
  } else if (command === "RECEIPT") {
    noBody(frame);
    verifyHeader(frame, ["receipt-id"]);
  } else if (command === "ERROR") {
    verifyHeader(frame, [], true);
  } else {
    return false;
  }

  return true;
}

function toServerFrame(ev) {
  const data = ev.data;
  const length = data.length || data.byteLength;

  if (length > 1) {
    const decoded = decode(data);

    if (!verifyServer(decoded)) {
      throw new MalformedFrameError("Unknown command: " + decoded.command);
    }

    return decoded;
  } else if (data[0] !== "\n" && data[0] !== 10) {
    throw new Error("Unknown message: " + data);
  }

  return null;
}

class Connection {
  constructor(url, options) {
    _defineProperty(this, "url", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "ws", void 0);

    _defineProperty(this, "_connected", false);

    _defineProperty(this, "_lastSend", 0);

    _defineProperty(this, "_lastRecv", 0);

    this.url = url;
    this.options = options;
  }

  send(frame) {
    const socket = this.ws;

    if (!socket) {
      return;
    }

    this._lastSend = Date.now();
    socket.send(encode(frame));
  }

  async listen(fn) {
    const socket = this.ws;

    if (!socket) {
      return undefined;
    }

    return new Promise((resolve, reject) => {
      const onclose = () => {
        reject(new Error("Socket closed."));
      };

      const onmessage = ev => {
        try {
          const frame = toServerFrame(ev.data);

          if (!frame) {
            return;
          }

          Promise.resolve(fn(frame)).then(processed => {
            if (processed) {
              off();
              resolve(frame);
            }
          }).catch(err => {
            off();
            reject(err);
          });
        } catch (err) {
          off();
          reject(err);
        }
      };

      const off = () => {
        socket.removeEventListener("close", onclose);
        socket.removeEventListener("message", onmessage);
      };

      socket.addEventListener("close", onclose);
      socket.addEventListener("message", onmessage);
    });
  }

  close() {
    const socket = this.ws;

    if (!socket) {
      return;
    }

    socket.close();
  }

  get connected() {
    return this._connected;
  }

  get host() {
    var _this$options;

    if ((_this$options = this.options) !== null && _this$options !== void 0 && _this$options.host) {
      return this.options.host;
    }

    const url = new URL(this.url);
    return url.host;
  }

  handleError(frame) {
    if ((frame === null || frame === void 0 ? void 0 : frame.command) === "ERROR") {
      var _this$ws;

      (_this$ws = this.ws) === null || _this$ws === void 0 ? void 0 : _this$ws.close();
      throw new Error(frame.headers.message);
    }
  }

  heartBeat(ws, heartBeat) {
    var _this$options2, _this$options3;

    const parts = heartBeat.split(",");
    const sx = parseInt(parts[0], 10);
    const sy = parseInt(parts[1], 10);
    const cx = ((_this$options2 = this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2.clientHeartBeat) || 0;
    const cy = ((_this$options3 = this.options) === null || _this$options3 === void 0 ? void 0 : _this$options3.serverHeartBeat) || 0;
    const clientHeartBeat = cx && sy ? Math.max(cx, sy) : 0;
    const serverHeartBeat = sx && cy ? Math.max(sx, cy) : 0;

    if (clientHeartBeat) {
      const interval = setInterval(() => {
        if (Date.now() - this._lastSend > clientHeartBeat / 2) {
          this._lastSend = Date.now();
          ws.send("\n");
        }
      }, clientHeartBeat / 2);
      ws.addEventListener("close", () => {
        clearInterval(interval);
      });
    }

    if (serverHeartBeat) {
      const interval = setInterval(() => {
        if (Date.now() - this._lastRecv > serverHeartBeat * 1.5) {
          ws.close();
        }
      }, serverHeartBeat);
      ws.addEventListener("message", () => {
        this._lastRecv = Date.now();
      });
      ws.addEventListener("close", () => {
        clearInterval(interval);
      });
    }
  }

  async connect() {
    if (!this.ws || this.ws.readyState === WebSocket.CLOSING || this.ws.readyState === WebSocket.CLOSED) {
      const ws = new WebSocket(this.url);
      this.ws = ws;
      ws.binaryType = "arraybuffer";
      await new Promise((resolve, reject) => {
        const onmessage = ev => {
          try {
            const frame = toServerFrame(ev);
            if (!frame) return;
            ws.removeEventListener("message", onmessage);
            this.handleError(frame);

            if (frame.command !== "CONNECTED") {
              throw new Error("Expect CONNECTED frame. Got " + frame.command);
            }

            this._connected = true;
            this._lastRecv = Date.now();
            this.heartBeat(ws, frame.headers["heart-beat"] || "0,0");
            resolve();
          } catch (e) {
            console.error(e);
            ws.close();
            reject(e);
          }
        };

        ws.addEventListener("message", onmessage);

        const send = () => {
          var _this$options4, _this$options5;

          this._lastSend = Date.now();
          const cx = ((_this$options4 = this.options) === null || _this$options4 === void 0 ? void 0 : _this$options4.clientHeartBeat) || 0;
          const cy = ((_this$options5 = this.options) === null || _this$options5 === void 0 ? void 0 : _this$options5.serverHeartBeat) || 0;
          ws.send(encode({
            command: "CONNECT",
            headers: {
              "accept-version": "1.2",
              host: this.host,
              "heart-beat": `${cx},${cy}`
            }
          }));
        };

        if (ws.readyState === WebSocket.OPEN) {
          send();
        } else {
          ws.onopen = send;
        }

        ws.addEventListener("close", () => {
          this.ws = undefined;
          this._connected = false;
          setTimeout(() => {
            this.connect();
          }, 500);
        });
      });
    }
  }

}

module.exports = Connection;
//# sourceMappingURL=index.js.map
